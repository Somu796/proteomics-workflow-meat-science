---
title: "down stream proteomics workflow for meat science"
author: "Sudipta Hazra"
format:
  html:
    code-link: true
    # code-line-numbers: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
execute:
  cache: true
---

[![](images/Summarized%20Experiment.png){fig-align="center" width="400"}](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)

## Parameters

```{r}
# do renv::restore() and renv:activate() as global setup

# Import quant_data and sample_data as parameter

feature_key_column <- "Accession" # comment it later
quantdata_key_column <- "Accession"
sample_key_column <- "sample" # quantCols (suggested names callouts)

# Instead only mention paths
quant_data_path <- "data/quant_data.csv"
s_data_path <- "data/sample_data.csv"

# refernce for columns in sample data,

treatmen1_ref <- "" # if kept empty nothing is considered as control
treatmen2_ref <- ""
# treatmen3_ref <- "" # keep adding as many treatments you have

# imputation technique
 imputation_algo <- "knn" #(suggest all the possible imputation but customizable): "orig", "knn", "zero", "MinDet", "bpca"
 
# normalisation techniques
normalization_algo <- "center.median" #sum, max, center.mean, center.median, div.mean, div.median, diff.median, quantiles, quantiles.robust, vsn

```

## Importing Data

### Gene ID has multiple entries one cell

#### Importing Raw Data

```{r}
# #| eval: false
# 
# pacman::p_load(tidyverse) 
# quant_data <- read.csv("data/sample_lfq_data.csv")
# # s_data <- read.csv("data/sample_metadata.csv") # sample_attributes
```

#### Enriching/populating the feature data

```{r}
# #| eval: false
# 
# # pacman::p_load(tidyverse, modules, httr, jsonlite) 
# # multipleAccessionHandling <- use("R/01_multipleAccessionHandling.R")
# source("R/01_multipleAccessionHandling.R")
# 
# 
# f_quant_data <- getCleanAccession(quant_data, "Accession", "\\b[A-Za-z0-9]+(?=\\|)")
# 
# r_data <- populateGeneNamesfromMultipleAccession(f_data, "Accession", ",", information = "accession,gene_primary,gene_synonym,organism_name,protein_name,sequence", countAccession = countAccession, getGeneUniProt = getGeneUniProt, getGeneInformationforMultipleAccession = getGeneInformationforMultipleAccession, verbose_ = FALSE)

```

### 

```{r}
# #| eval: false
# 
# pacman::p_load(import, glue, httr, progress)
# 
# # write.csv(r_data[, c(1, 7:ncol(r_data))],"data/quant_data.csv", row.names = FALSE)
# 
# write.csv(r_data[, 1:6], "data/feature_data.csv", row.names = FALSE)
```

### Gene ID has single entries in cell

#### Importing Raw Data

```{r}
pacman::p_load(tidyverse)

quant_data <-  read.csv(quant_data_path) #%>%  # LFQ quantified data
  # column_to_rownames(var = feature_key_column) # make the first column as row name

f_data <- read.csv("data/feature_data.csv") #%>% # feature_attributes, primary key (unique) should be uniprot accession gene id
  # column_to_rownames(var = feature_key_column)

s_data <- read.csv(s_data_path) %>% 
  mutate(across(all_of(sample_key_column), make.names)) %>%
  # column_to_rownames(var = sample_key_column) %>% 
  dplyr::rename(quantCols = sample_key_column)
```

## Preparing a QFeature object

### Creating the QFeature object

```{r}

pacman::p_load(BiocManager, BiocStyle) # will go to global environment
pacman::p_load(QFeatures)

# creating assayData
assayData <-  f_data %>% 
  full_join(quant_data, by = feature_key_column)

# name for the assay
initial_assayName <- "proteomics_data"

# creating QFeature object
data <- readQFeatures(
  assayData,
  quantCols  = (ncol(f_data)+1):ncol(assayData),
  fnames = feature_key_column,
  colData = s_data,
  name = initial_assayName
)

# adding column details also for summarizedExperiment object
colData(data[[initial_assayName]]) <- colData(data)
```

### Inspecting the QFeature Object

::: panel-tabset
##### QFeature object

```{r}
# QFeature object
data
```

##### summarizedExperiment Object

```{r}
# summarizedExperiment Object
data[[initial_assayName]]
```

##### row data (features) information

```{r}
# row data (features) information
head(rowData(data[[initial_assayName]]), 3)
```

##### col data (samples) information (summarizedExperiment object)

```{r}
# col data (samples) information
head(colData(data[[initial_assayName]]), 3) #summarizedExperiment object

```

##### col data (samples) information (QFeature object)

```{r}
# col data (samples) information
head(colData(data), 3) # QFeature object
```

##### assay data

```{r}
# assay data
head(assay(data[[initial_assayName]]), 2)

```

```{r}
#| eval: false

# QFeature object
message(" QFeature object")
data

# summarizedExperiment Object
message("\n \n summarizedExperiment Object")
data[[initial_assayName]]

# row data (features) information
message("\n \n row data (features) information")
head(rowData(data[[initial_assayName]]), 3)

# col data (samples) information
message("\n col data (samples) information (summarizedExperiment object)")
head(colData(data[[initial_assayName]]), 3) #summarizedExperiment object

message("\n col data (samples) information (QFeature object)")
head(colData(data), 3) # QFeature object

# assay data
message("\n \n assay data")
head(assay(data[[initial_assayName]]), 2)

message("\n \n Warning: We are printing less rows for a better viewing using head() function.")
```
:::

## Pre-processing of the data

### Missing value Handling

#### Missing value exploration and visualization

::: {.panel-tabset .nav-pills}
###### Descriptive Information

```{r}
# Exploring missing values
data[[initial_assayName]] <- zeroIsNA(data[[initial_assayName]])
NA_data <- nNA(data[[initial_assayName]])
NA_data
```

###### Missing value visualization of overall data

```{r}
# Visualizing the whole data
pacman::p_load(naniar)

vis_miss(as.data.frame(t(assay(data[[initial_assayName]]))), sort_miss = TRUE, show_perc_col = FALSE) +
  labs(x = "Genes") +
  theme(axis.text.x = element_blank())
```

###### Missing value visualization of features with missing data

```{r}

col_with_missingval <- as.data.frame(t(assay(data[[initial_assayName]]))) %>%
  select(where(~ any(is.na(.))))

vis_miss(col_with_missingval, sort_miss = TRUE, show_perc = FALSE) +
  labs(x = "Genes") +
  theme(axis.text.x = element_text(face="bold", size = 7, angle = 90))
```
:::

#### Missing data filterting

Filtering features having more than 10% missing data.

```{r}

# removing missing value more than 10%, can be changed accordingly

NA_filtered_assayName <- paste0("NAfiltered_", initial_assayName)

data <- addAssay(data,

                 filterNA(

                   data[[initial_assayName]],

                   pNA = 0.1

                 ),

                 name = NA_filtered_assayName)

```

#### Missing Data Imputation

##### Packages needed

```{r}
pacman::p_load(limma, impute)
```

##### Log transformation for easy visualization of imputation

```{r}
log_NA_filtered_assayName <- paste0("log_",NA_filtered_assayName)
data <- addAssay(data,
                 logTransform(data[[NA_filtered_assayName]]),
                 name = log_NA_filtered_assayName)
```

##### Imputing missing values and visualization (modify later)

```{r}
#| eval: false
source("R/02_QFeature_related functions.R")

# fix the function
visualize_imputation_density(data, 
                             protein_column = NA_filtered_assayName, 
                             imputation_methods = c("knn", "zero", "MinDet", "bpca"),
                             colors = c("black", "red", "blue", "steelblue", "orange"),
                             legend_position = "topright")

```

##### Imputation with imputation_algorithm mentioned in parameters

```{r}

imputed_NA_filtered_assayName <- paste0("imputed_", NA_filtered_assayName)
data <- addAssay(data,
                 impute(data[[NA_filtered_assayName]], method = tolower(imputation_algo)),
                 name = imputed_NA_filtered_assayName
)

```

### Log transformation

```{r}

log_imputed_NA_filtered_assayName <- paste0("log2_", imputed_NA_filtered_assayName)

data <- addAssay(data,
                 logTransform(data[[imputed_NA_filtered_assayName]], base = 2),
                 name = log_imputed_NA_filtered_assayName)
```

### Normalisation

##### Visualization of different \`normalisation\`

##### Applying \`normalisation\` to our dataset

```{r}

norm_log_imputed_NA_filtered_assayName <- paste0("norm", log_imputed_NA_filtered_assayName)

data <- addAssay(data,
                 normalize(data[[log_imputed_NA_filtered_assayName]],
                           method = normalization_algo),
                 name = norm_log_imputed_NA_filtered_assayName)
```

## Exploratory Analysis

### Packages

```{r}
pacman::p_load(
  ggplot2, 
  # plotly, # for interactive plotting
  glue,
  gridExtra
)
source("R/03_getDimensionalReduction.R")

```

### Visualization

```{r}
# PCA
df_dimensionaReduction <- data[[norm_log_imputed_NA_filtered_assayName]] %>% 
  assay() %>%
  t()

sample_dimensionaReduction <- data[[norm_log_imputed_NA_filtered_assayName]] %>%
  colData() %>% 
  assay() %>% 
  as.data.frame()

labels <- sample_dimensionaReduction %>% select(- "quantCols")

```

::: panel-tabset
#### PCA

```{r}
# Defining PCs to plot 

x = 1 # PC1
y = 2 # PC2
model = "pca"

# Model building 
pca_model <- prcomp(df_dimensionaReduction, scale. = TRUE) 

# Extracting PCs 
pca_data <- as.data.frame(pca_model$x)

# Calculating explained variance 
explained_variance <- pca_model$sdev^2 / sum(pca_model$sdev^2)
explained_variance <- round(explained_variance * 100, 2)

# Preparing Scree Plot

scree_plot_data <- data.frame(
  PC_component = paste0('PC ', 1: nrow(df_dimensionaReduction)), 
  explained_variance = cumsum(explained_variance)
) # changed: nrow(metabo_data)

components_to_show = 10

scree_plot <- generate_pca_scree_plot(scree_plot_data, components_to_show)

# preparing plot in a list t be plotted
plot_list <- list()
plot_list[["scree_plot"]] <- scree_plot

for (label in colnames(labels)) {
  assign(paste0("fig_pca_Plot_", label), 
         generate_dimension_reduction_plot(
           model, 
           x, 
           y, 
           pca_data, 
           label, 
           labels, 
           explained_variance = NULL))
  
  plot_list[[paste0("fig_pca_Plot_", label)]] <- get(paste0("fig_pca_Plot_", label))
}

suppressWarnings({
  n <- dim(matrix(1:(ncol(sample_dimensionaReduction)), nrow = 2))[2]
  p <- dim(matrix(1:(ncol(sample_dimensionaReduction)), nrow = 2))[1]
})

# You can also extract plots individually as plot_list$scree_plot, and save with ggsave()
grid.arrange(grobs = plot_list, nrow = n, ncol = p) 

```

#### t-SNE

```{r}
#| message: false
#| warning: false

pacman::p_load(tsne) #Rtsne,

# Defining parameters to plot 
x = 1
y = 2 
perplexity = 20
model = "tsne"

# Model building 
set.seed(0)
tsne_model <- tsne(df_dimensionaReduction, initial_dims = 2)
# tsne_model <- Rtsne(df, perplexity = perplexity, pca_scale = TRUE) # Alternative

# Extracting tSNE components 
tsne_data <- data.frame(tsne_model)
# tsne_data <- as.data.frame(tsne_model$Y) # Alternative

rownames(tsne_data) <- rownames(df_dimensionaReduction)


# preparing tSNE plots 
plot_list <- list() 
for (label in colnames(labels)) {
  assign(paste0("fig_tsne_Plot_", label), 
         generate_dimension_reduction_plot(
           model, 
           x, 
           y, 
           tsne_data, 
           label, 
           labels, 
           explained_variance = NULL))
  
  plot_list[[paste0("fig_tsne_Plot_", label)]] <- get(paste0("fig_tsne_Plot_", label))
}

suppressWarnings({
  n <- dim(matrix(1:(ncol(sample_dimensionaReduction)-1), nrow = 2))[2]
  p <- dim(matrix(1:(ncol(sample_dimensionaReduction)-1), nrow = 2))[1]
})

grid.arrange(grobs = plot_list, nrow = n, ncol = p) 

```

#### UMAP

```{r}
pacman::p_load(umap)

# Defining parameters to plot 
x = 1
y = 2 
model = "umap"

# Model building  
set.seed(0)
umap_model <- umap(df_dimensionaReduction, n_components = 2, random_state = 15)

# Extracting UMAP components
umap_data <- data.frame(umap_model[["layout"]]) 

# preparing UMAP plots 
plot_list <- list()

for (label in colnames(labels)) {
  assign(paste0("fig_umap_Plot_", label), 
         generate_dimension_reduction_plot(
           model, 
           x, 
           y, 
           umap_data, 
           label, 
           labels, 
           explained_variance = NULL))
  
  plot_list[[paste0("fig_umap_Plot_", label)]] <- get(paste0("fig_umap_Plot_", label))
}

# Automating the grids for plottig
suppressWarnings({
  n <- dim(matrix(1:(ncol(sample_dimensionaReduction)-1), nrow = 2))[2]
  p <- dim(matrix(1:(ncol(sample_dimensionaReduction)-1), nrow = 2))[1]
})

grid.arrange(grobs = plot_list, nrow = n, ncol = p) 

```
:::

## Statistical Analysis

### LIMMA Analysis

```{r}
#| eval: false

pacman::p_load(limma, tidyverse)
source("R/04_limma.R")
# parameters
multiple_testing_adjusting_method <- "none" # possible methods: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr", "none", check p.adjust.methods for more.

# Importing the numeric data and corresponding sample_data for Differential Expression Analysis
assay_data <- assay(data[[norm_log_imputed_NA_filtered_assayName]])
sample_data <- colData(data)[, -1]

# Converting character columns into a singular column
if(all(sapply(sample_data, is.character))) {
  # Collapse columns into a new column if all are character type
  sample_data$combined <- apply(sample_data, 1, function(row) paste(row, collapse = "_and_"))
  sample_data$combined <- factor(sample_data$combined)
} else {
  stop("Not all columns are character types!")
}

# Creating a design matrix
design <- model.matrix(~ 0 + combined, data = sample_data)
colnames(design) <- gsub("combined", "", colnames(design))

# fitting the model
fit <- lmFit(assay_data, design)
print(colnames(design))

# creating contrasts
custom_contrasts <- c(
  Stress_vs_NoStress = "(Stress_and_Lipid_VitE_PlantExt + Stress_and_Lipid_VitE + Stress_and_Lipid)/3 - (NoStress_and_Lipid + NoStress_and_Lipid_VitE + NoStress_and_Lipid_VitE_PlantExt)/3",
  Lipid_VitE_vs_Lipid_NoStress = "NoStress_and_Lipid_VitE - NoStress_and_Lipid",
  Lipid_VitE_PlantExt_vs_Lipid_NoStress = "NoStress_and_Lipid_VitE_PlantExt - NoStress_and_Lipid",
  Lipid_VitE_PlantExt_vs_Lipid_VitE_NoStress = "NoStress_and_Lipid_VitE_PlantExt - NoStress_and_Lipid_VitE",
  Lipid_VitE_vs_Lipid_Stress = "Stress_and_Lipid_VitE - Stress_and_Lipid",
  Lipid_VitE_PlantExt_vs_Lipid_Stress = "Stress_and_Lipid_VitE_PlantExt - Stress_and_Lipid",
  Lipid_VitE_PlantExt_vs_Lipid_VitE_Stress = "Stress_and_Lipid_VitE_PlantExt - Stress_and_Lipid_VitE"
)

contrasts_group <- makeContrasts(contrasts=custom_contrasts,levels=design)

fit_contrasts <- contrasts.fit(fit, contrasts_group)
fit_contrasts_bayes <- eBayes(fit_contrasts)


DAP_table <- getDAPlist(fit_contrasts_bayes, contrasts_group, information_DE = c("logFC","AveExpr", "P.Value","adj.P.Val"), multiple_testing_adjusting_method = "none")


```
```{r}
#| eval: false
#| echo: false

## No need to run locally
# this is because there is an issue in rendering the previous code chunk, however it works well in local
save(DAP_table, file = "Data/DAP_table.RData")
```

```{r}
#| echo: false
## No need to run locally
load("Data/DAP_table.RData")
```

### LIMMA Result Visualization

::: {.panel-tabset .nav-pills}
#### LIMMA Result Table

```{r}
pacman::p_load(reactable)

feature_data <- rowData(data[[norm_log_imputed_NA_filtered_assayName]]) %>% as.data.frame()

DAP_table_feature_data <- feature_data[, c(quantdata_key_column, "Gene_primary", "Protein_name")] %>%
  right_join(
    rownames_to_column((DAP_table),
                       var = quantdata_key_column),
    by = quantdata_key_column)

rmarkdown::paged_table(DAP_table_feature_data)
```

#### Volcano Plot
```{r}
#| message: false
# Volcano Plot for Stress vs No Stress

pacman::p_load(ggplot2,
               extrafont,
               ggrepel,
               glue,
               ggpp)
loadfonts(device = "win")
source("R/04_limma.R")

# use gg_table to include the gene names
DAP_table_factor <- DAP_table_feature_data[, c("Gene_primary", "logFC_Stress_vs_NoStress", "adj.P.Val_Stress_vs_NoStress")]
FactorLevel.1 <- "Stress"
FactorLevel.2 <- "NoStress"
legend_title = "pre-slaughter \nstress condition"


getVolcanoPlot(DAP_table_factor, FactorLevel.1, FactorLevel.2, mrlimit = 1.2, legend_title = legend_title)


```
#### UpSet Plot

```{r}
#| message: false
pacman::p_load(ggupset, grid)
source("R/04_limma.R")

# This is for differences between feeding regime given stress and no stress
pValue_Limit= 0.05
DAP_table_feature_interaction <- DAP_table_feature_data[, c(1:3, 8:ncol(DAP_table_feature_data))] %>% 
  column_to_rownames(quantdata_key_column)

colnames(DAP_table_feature_interaction) <- gsub("_vs_", "-", colnames(DAP_table_feature_interaction))

# NOSTRESS DATA: data.frame for differences between feeding regime given no stress
## column names having adj.P.Value and _NoStress is getting filtered
col_names_nostress_df <- grepl(
  "adj\\.P\\.Val.*_NoStress", 
  colnames(DAP_table_feature_interaction)
)
nostress_df <- DAP_table_feature_interaction[, col_names_nostress_df]
## the column names are getting clean
colnames(nostress_df) <- gsub("adj.P.Val_|_NoStress", "", colnames(nostress_df))

## creating column that to be plotted in upSet diagram
no_of_comparison_col_nostress<- 1:ncol(nostress_df)

for (i in 1: nrow(nostress_df)){
  nostress_df$comparison[i] <- str_replace_all(
    paste(
      unlist(
        colnames(nostress_df)[c(no_of_comparison_col_nostress)][nostress_df[i, no_of_comparison_col_nostress] <0.05]
        ), collapse = "&")
    , "_", "+")
}

## genes having none of the comparisons significant getting filtered
upSet_data_nostress <- nostress_df %>% 
  filter(comparison != "") %>% 
  select(comparison) %>% 
  table()

# STRESS DATA: data.frame for differences between feeding regime given stress
## column names having adj.P.Value and _Stress is getting filtered
col_names_stress_df <- grepl(
  "adj\\.P\\.Val.*_Stress", 
  colnames(DAP_table_feature_interaction)
)
stress_df <- DAP_table_feature_interaction[, col_names_stress_df]
## the column names are getting clean
colnames(stress_df) <- gsub("adj.P.Val_|_Stress", "", colnames(stress_df))

## creating column that to be plotted in upSet diagram
no_of_comparison_col_stress <- 1:ncol(stress_df)
for (i in 1: nrow(stress_df)){ #
  stress_df$comparison[i] <- str_replace_all(
    paste(
      unlist(
        colnames(stress_df)[c(no_of_comparison_col_stress)][stress_df[i,no_of_comparison_col_stress] <0.05]
      ), collapse = "&"
    ), "_", "+")
}

## genes having none of the comparisons significant getting filtered
upSet_data_stress <- stress_df %>% 
  filter(comparison != "") %>% 
  select(comparison) %>% 
  table()


upset1 <- getUpSetPlot(upSet_data_nostress, title = "A)", fill_color = "#1F77B4")

upset2 <- getUpSetPlot(upSet_data_stress, title = "B)", fill_color = "#FF7F0E")

grid.arrange(grobs = list(upset1, upset2), ncol = 2)

```
:::

## Ensemble Feature Selection

`EFS` package only support target variables with two levels. Here we will perform the analysis  with factor `pre-slaughter stress condition` which has two levels a) limited stress (No Stress), b) additional stress (Stress). We will be using NA filtered and imputed columns.

### Data Preparation
```{r}
pacman::p_load(EFS)

# Preparing data for EFS
EFS_data <- assay(data[[imputed_NA_filtered_assayName]]) %>% 
  t() %>% 
  as.data.frame() 
sample_data <- colData(data)[, -1] %>% 
  as.data.frame()

EFS_data <- sample_data %>% 
  select(Slaughter_Condition)%>% 
  merge(EFS_data, by = 0) %>% 
  column_to_rownames(var = "Row.names")

EFS_data$Slaughter_Condition <- ifelse(EFS_data$Slaughter_Condition == "Stress", 1, 0)

rmarkdown::paged_table(EFS_data)
```

### Performing feature selection
```{r}
#| message: false
efs <- ensemble_fs(data = EFS_data, classnumber = 1,
                   NA_threshold = 0.2, cor_threshold = 0.7,
                   runs = 100) #, selection = rep(TRUE, 8)

```

### Result Visualization

#### cumulative barplot
```{r}
source("R/05_EFS.R")
barplot_efs(efs)

```
#### ROC Curve for model evaluation
```{r}
#| eval: false
#| echo: false

# Create a ROC Curve based on the output from efs
eval_tests <- efs_eval(data = EFS_data, efs_table = efs,
                       file_name = "docs/Horn",
                       classnumber = 1, NA_threshold = 0.2,
                       logreg = TRUE,
                       permutation = TRUE, p_num = 100,
                       variances = TRUE, jaccard = TRUE,
                       bs_num = 100, bs_percentage = 0.9)


```


<!-- ## Enrichment -->

<!-- # KEGG and SPIA -->

<!-- # GO Enrichment -->
